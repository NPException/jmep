{"name":"Jmep","tagline":"Automatically exported from code.google.com/p/jmep","body":"#The next big task\r\n\r\nThis project has been cute so far ... but the Shunting algorithm isn't going to cut it for me anymore. The syntactical processing of the current algorithm has grown pretty stable, but I have decided that it is worth converting it over to using either JavaCC or ANTLR. This will separate the Syntax description through abstracting the AST (Abstract Syntax Tree). I believe that this will be cause for better processing offering following benefits:\r\n  * Faster, I hope ...\r\n  * Better pinpointing of error locations.\r\n  * Solve the issue of zero parameter functions (doesn't work in the current implementation).\r\n  * Easier and faster to fix newly discovered issues, or implement new features\r\n  * Minimize complex java coding\r\n\r\n> *Update! Update! It is that far - I have started a new project to support better grammar!*<br>Visit [the grammar project](http://code.google.com/p/jgrammar) !\r\n\r\n\r\n\r\n#Parse and evaluate mathematical expressions.\r\n\r\nThis Expression parser is intended to work as natural as possible, and in doing so will actually deviate from what expressions in a language like java or C would do. Special care has been made for optimizing expression evaluation by carefully separating out the parsing step from the actual evaluation step, allowing faster consecutive execution of the same expression with different parameters.\r\n\r\nIts use is simple:\r\n\r\n    int x = 0;\r\n    Environment env = Environment.getInstance(Expression.OperationalMode.BASIC);\r\n    // Add a unit called 'mm' to the environment\r\n    env.registerUnit(\"mm\", Double.class, (t)->0.001*t);\r\n    env.addVariable(\"time\",()->System.currentTimeMillis()/1000);\r\n    env.addVariable(\"x\",()->x);\r\n    expression = new Expression(\"2*x\",env);\r\n    result = expression.evaluate();\r\n    System.out.println(\"Result = (\"+result.getClass().getSimpleName()+\")\" + result);\r\n    x = 10;\r\n    // No need to recompile the expression, just evaluate again, and the new value for x will be automatically captured.\r\n    result = expression.evaluate();\r\n    System.out.println(\"Result = (\"+result.getClass().getSimpleName()+\")\" + result);\r\n\r\nThe parser has built-in knowledge about operator precedence. Operator precedence is predetermined, and cannot be changed at run-time. It matches Operator Precedence as defined for expressions in languages like Java and C.\r\n\r\nThis API is completely agnostic to the type of the operators, and in fact will accept any type extending Object, that simple. The work is just in registering implementations for\r\n  * Binary Operators\r\n  * Unary Operators\r\n  * Units of Measure\r\n  * Constants and Variables\r\n  * Up-Conversions\r\n\r\nLook at the documentation for [Complex how to add support for Complex numbers], to see how some of these can be implemented. You will note the use of Lambda expressions throughout.\r\n\r\nA `BasicEnvironment` is already preconfigured to operate on `String`, `Long`, and `Double`. `Boolean` support is built in by evaluating true/false as 1/0. \r\n\r\nEqually a `FinancialEnvironment` has been preconfigured to be more stricter, and disallow the usage of `Double` and preferring `BigDecimal` instead. We could have been more lenient by allowing a mix of `Double` and `BigNumber`, but such restrictions promotes proper use in financial applications. The programmer is left free to maybe create their own `LenientFinancialEnvironment`, or `MixedFinancialEnvironment`, but then it is up to the final user to be careful not to use calculations that break the integrity of the numbers.\r\n\r\nFor those interested, the compilation phase of expressions is implemented using [the Dijkstra shunting-yard algorithm](http://en.wikipedia.org/wiki/Shunting-yard_algorithm).\r\n\r\nExecution should be fast, as it has a 3 step, compile-bind-execute approach.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}